Oracle Java SE 11 Gold (1Z0-816-JPN) 出題範囲の詳細

試験の主要トピックとカテゴリ一覧

Oracle認定資格「Java SE 11 Gold」（1Z0-816-JPN）の出題範囲は、大きく17のカテゴリに分かれています ￼。各カテゴリとその主な内容は次のとおりです。
	•	Javaの基礎 – finalクラスの作成と利用、ネストしたクラス（インナークラス・staticインナークラス・ローカルクラス・無名クラス）の定義と使用、列挙型（enum）の定義と利用 ￼。（※インナークラスは外部クラスのインスタンスが必要だが、staticインナークラスは不要など、違いを押さえる ￼。また抽象クラスとインタフェースの相違点も理解しておきましょう。）
	•	例外処理とアサーション – 例外処理の構文（try-with-resources構文を含む） ￼、カスタム例外クラスの作成とスロー方法、assertキーワードによるアサーションの使用と無効化/有効化方法 ￼。
	•	Javaのインタフェース – インターフェースの拡張機能として、デフォルトメソッドの定義と利用、プライベートメソッドの定義と利用 ￼。（※Java 8以降はインタフェースにstaticメソッドも定義可能。Java 9でプライベートメソッドが追加されました ￼。）
	•	ジェネリクスとコレクション – ラッパークラスと基本型のオートボクシング/アンボクシング ￼、総称型（ジェネリクス）クラス・メソッドの定義と<>（ダイアモンド演算子）やワイルドカード（? extendsや? super）の使用 ￼、コレクションフレームワークの概要と主要コレクションインターフェース（List、Set、Queue、Mapなど）の利用 ￼、ComparatorとComparableインタフェースの活用、およびコレクションに対する便利なメソッド（Java 8で追加されたremoveIfやsortなど）の使用 ￼。
	•	関数型インタフェースとラムダ式 – 関数型インタフェース（抽象メソッド1つだけを持つインタフェース）の宣言と記述 ￼、ラムダ式の文法（引数リスト、省略可能な型/括弧、->、本体が式かブロックか）と使い方 ￼。ラムダ式内で使用できるローカル変数は**実質的にfinal**でなければならない点（変更不可の制約）にも注意します ￼。
	•	JavaストリームAPI – Stream APIによるコレクション処理：Streamインタフェースとストリームパイプライン（データソース→中間操作→終端操作）の概念 ￼、ラムダ式やメソッド参照を用いたストリーム操作 ￼。
	•	組み込み関数型インタフェース – Java標準の関数型インタフェース群（java.util.functionパッケージ）の利用 ￼。主要な関数型インタフェースであるPredicate（条件テスト）、Consumer（利用）、Function（変換）、Supplier（供給）などの使い方 ￼、およびそれらの原型に対するプリミティブ型用・二項用バリエーション（例えばIntConsumerやBiFunction等）の活用 ￼。
	•	ストリームに対するラムダ演算 – Stream APIを使った具体的な操作群。 ￼例えば:
	•	中間操作：map（各要素の写像）, peek（各要素への副作用処理）, flatMap（ネストしたストリームの平坦化） ￼。（※filterやsorted等も頻出）
	•	検索操作：findFirst/findAny（要素の検索）、anyMatch/allMatch/noneMatch（条件マッチの判定） ￼。
	•	その他：Optionalクラスの活用（Optional<T>から値を安全に取り出す方法） ￼。
	•	終端操作による集計：count, max, min, average, sum等でストリーム要素を集計 ￼。
	•	コレクションのソート：Collections.sort()やList.sort()にラムダ式のコンパレータを渡して並べ替え ￼。
	•	コレクタの利用：Collectorsクラスを使ってストリーム結果を収集（特に**groupingByによるグルーピングやpartitioningBy**による条件分割など） ￼。
	•	モジュール型アプリケーションへの移行 – Javaモジュールシステム（JPMS）の概要と旧来コードのモジュール化。 ￼Java SE 8までの従来アプリケーションをモジュールに分割し、Java 9以降のモジュール方式へ移行する方法（トップダウン移行とボトムアップ移行） ￼。モジュールパス（modulepath）とクラスパス（classpath）の違い、それぞれでのアプリケーション実行方法 ￼。依存関係解析ツールjdepsの使用方法と、モジュール間の循環依存の検出・対処 ￼。
	•	モジュールサービス – モジュールにおけるサービス機能の活用。 ￼モジュールのmodule-info.javaでのサービス提供者(provides ... with ...)とサービス利用者(uses)の宣言方法、サービスの構成要素（サービスインタフェースと実装） ￼。ServiceLoaderによるサービス実装の読み込みと、コンシューマ・プロバイダモジュール間の依存関係の確認 ￼。
	•	並列処理（マルチスレッド） – Javaでのマルチスレッドプログラミング。 ￼RunnableやCallableを実装したワーカースレッドの作成方法、スレッドプール/API（ExecutorService）を使用したタスクの並行実行 ￼。java.util.concurrentパッケージの並行コレクション・ユーティリティクラス（例：CyclicBarrier、CopyOnWriteArrayListなど）の利用 ￼。スレッドセーフなコードの書き方（クリティカルセクションの同期化など） ￼と、デッドロック・ライブロックなどスレッド特有の問題の識別 ￼。
	•	並列ストリーム – Parallel Streamsによるストリーム処理の高速化。 ￼並列ストリーム（parallelStream()など）を使ったコードの開発、ストリーム処理の並列実行における分割とリダクション（要素の分割処理と集約処理）の仕組みを理解する ￼。
	•	入出力（I/O）とNIO2 – 標準の入出力APIおよびNIO.2（New I/O）のファイル操作。 ￼コンソールやファイルに対してバイトストリーム/キャラクタストリームでデータを読み書きする方法（InputStream/OutputStreamやReader/Writerの基本） ￼。オブジェクトのシリアライズとデシリアライズ（ObjectInputStream/ObjectOutputStreamの使用） ￼。Pathインタフェースによるファイル/ディレクトリパスの操作（ファイルパスの結合・解決など） ￼。Filesユーティリティによるファイル/ディレクトリのチェック、削除、コピー、移動といった操作 ￼。ファイルに対するStream APIの活用（例：Files.lines(path)でファイル内容をストリーム処理） ￼。
	•	Java SEアプリケーションにおけるセキュアコーディング – セキュリティを考慮したコーディング手法 ￼。JavaアプリでのDoS攻撃の防止（無限ループや過剰メモリ消費を避ける等） ￼、機密情報の保護（平文パスワードを避ける、機微な情報をログ出力しない等） ￼、入力データの検証やコードインジェクション防止などデータ整合性の確保 ￼、クラスのアクセス制御や継承制限・不変オブジェクト化による外部からの攻撃防止 ￼、機密オブジェクト（例えば機密性の高いクラスインスタンス）を安全に構築・扱う方法 ￼、シリアライズ/デシリアライズ時の安全対策（serializableクラスの読み取り制限など） ￼。
	•	JDBCによるデータベースアプリケーション – JDBCを用いたデータベース接続と操作。 ￼JDBC接続文字列（URL）とDriverManagerを使ったデータベース接続 ￼、PreparedStatementを利用したSQLの実行（CRUD操作）と結果の取得 ￼、ストアドプロシージャ呼び出しのためのCallableStatementの利用方法 ￼。トランザクション制御や例外処理の取り扱いも含みます。
	•	ローカライズ（国際化） – アプリケーションの多言語対応。 ￼Localeクラスの利用によるロケール（地域/言語設定）の指定 ￼、ResourceBundleを用いたリソースファイル（プロパティファイル等）からの文字列取得 ￼、日付・時刻や数値のロケールに応じたフォーマット処理（DateTimeFormatterやNumberFormatなどの使用） ￼。
	•	アノテーション – **アノテーション（標注）**機能の利用。 ￼アノテーションの目的と一般的な使用パターン ￼、クラスやメソッドへの標準アノテーション（例えば@Override, @Deprecated, @SuppressWarningsなど）の適用方法と効果 ￼、よく使われるJDK組込みアノテーションの役割 ￼、独自アノテーションの宣言と、そのために必要なメタアノテーション（@Retention、@Target等）について ￼。

Java SE 11特有の仕様・新機能

Java SE 11時点で新たに加わった主な言語仕様や機能にも留意が必要です（Java 8以降の変更点を含む）。試験範囲に関連する重要なポイントを挙げます。
	•	varによるローカル変数の型推論 – Java 10で導入された機能で、ローカル変数宣言時に型名の代わりにvarキーワードを使うと、右辺の初期値から型を自動推論できます ￼。例えばvar list = new ArrayList<String>();のように記述します。型推論されても静的型付けである点は変わらず、一度推論された型以外の値は代入できません ￼。注意: varはローカル変数限定で使用可能であり、メンバ変数やメソッドの引数型・戻り値型には使えません。また、初期化子がnullだと型を特定できずコンパイルエラーになる等の制約があります ￼ ￼。
	•	ラムダ式でのローカル変数使用制限 – ラムダ本体から参照するローカル変数は**「実質的にfinal」**でなければなりません。つまり、一度値を代入した後に再代入されない変数（最終的に変更されない変数）のみキャプチャできます ￼。この制約はJava 8からの仕様ですが、見落としやすいポイントです。また、ラムダ式内ではbreakやcontinueで外側ループを制御したり、returnで外側メソッドから抜けたりすることはできません ￼（ラムダはあくまで値を返す式として扱われ、独立したブロックとみなされます）。
	•	インタフェースのデフォルトメソッド・プライベートメソッド – Java 8でインタフェースにデフォルトメソッド（defaultメソッド）が、Java 9でプライベートメソッドが導入されました ￼。これによりインタフェースでも実装付きのメソッドを定義でき、既存コードとの互換性や実装の共通化が図れます。デフォルトメソッドは実装クラスでオーバーライド可能なインスタンスメソッド、プライベートメソッドはインタフェース内だけで利用されるヘルパーメソッドとして位置づけられます（インタフェースの設計意図を把握しておきましょう ￼）。staticメソッドも含め、インタフェースのメソッド種類と用途は整理しておく必要があります。
	•	Javaプラットフォームモジュールシステム（JPMS） – Java 9で導入されたモジュールシステムにより、module-info.javaでモジュールの宣言（module X { requires Y; exports pkg; }等）を行い、パッケージ単位のアクセス制御や依存関係管理が可能になりました。従来のクラスパスに対しモジュールパスを用いる仕組みや、オープンモジュール(opens)によるリフレクション許可など、Java 11時点でのモジュールシステムの使い方を理解しておきましょう。試験では既存コードのモジュール化手順や、モジュール間の依存関係エラーの解決策などが問われます ￼。サービス機能（provides/uses）もモジュールシステム特有の構文です。
	•	その他のJava11対応事項 – Java 11自体の言語拡張は少ないですが、例えばローカル変数の型推論をラムダ式の引数に使用可能になった点があります（Java 11, JEP323）。ラムダの仮引数を(var x, var y) -> {...}のように書けますが、一部だけvarを混在させることはできない等の制約があります。また、Java 9以降でStream APIに追加されたメソッド（takeWhile/dropWhile, ofNullableやOptionalのifPresentOrElse等）もありますが、試験の中心はありません。セキュアコーディングやモジュールといったトピックはJava SE 11試験から新たに加わった分野であり ￼、過去バージョン試験に無かった分だけ重点的に対策しておくと良いでしょう。

重要分野と頻出ポイント・落としやすいミス

上記の中でも特に頻出の分野、および受験者が注意すべきポイントをまとめます。
	•	ラムダ式とStream API – 最重要分野です。体感で試験問題の半数近くがラムダ式・関数型インタフェースやストリーム関連のトピックでした ￼。したがって、この分野を集中的に対策しましょう。具体的には、主要な組み込み関数型インタフェース（Supplier,Consumer,Predicate,Functionなど）の全てのメソッドシグネチャ（引数と戻り値の型）を暗記すること ￼。ラムダ式の文法（省略可能な括弧や型、矢印の位置、ブロックと戻り値の関係）やメソッド参照の書き方にも慣れておくと、選択肢の誤りを見抜きやすくなります ￼。
Stream APIではストリームパイプラインの実行順序を正しく理解しておくことが重要です。例えば、中間操作のfilter→peek→map→終端操作forEachという流れがあった場合、データ要素は1つずつ順にパイプラインを流れるのであって、filterですべて絞り込んでからpeekに渡されるわけではありません ￼（各要素がフィルタ通過→ピーク処理→マップ変換→…と逐次処理されるイメージ）。この点を勘違いすると、例えばpeekで得られる要素数を誤解する原因になります ￼。
またストリームの終端操作は1つのストリームにつき1回しか呼び出せないことにも注意しましょう。1つのストリームで2回以上終端操作メソッドを呼ぶと、実行時にIllegalStateExceptionが発生します ￼。
Optionalクラスも頻出です。Optional.empty()なオブジェクトに対してget()を呼ぶと例外が投げられる ￼点や、orElse/orElseGet/orElseThrowの違いを押さえてください。Optionalはnullチェックを安全に行うためのクラスですが、誤った使い方（結局get()でNullPointerと同様の例外を起こす等）をしないようにする知識が問われます。
CollectorsのgroupingBy/partitioningByは複雑ですが試験で頻出のため、余裕があれば使い方を深く理解しておくのが望ましいです ￼（オーバーロードされたバリエーションも含め、引数に何を渡す必要があるかなど把握する）。特にgroupingByによるネストした収集操作の結果型（Mapのキーと値の型など）は混乱しやすいポイントです。
	•	マルチスレッドと並行処理 – 並列処理も重要分野の一つです。スレッドの生成と実行、スレッドプールの利用に関する問題が出題されます。スレッドセーフにする方法（例えば共有データへアクセスする際のsynchronizedブロックやReentrantLockの適切な利用法）を理解しておきましょう ￼。排他制御のキーワードやクラス名だけでなく、正しい実装パターンまで知っておく必要があります ￼。
併せて、スレッド化による弊害にも注意します。代表的なものはデッドロック（相互待ち状態）、ライブロック、競合状態（競馬条件）などです。それぞれどういった状況で発生し、どう防止・対処するかを問われる可能性があります ￼。例えば「あるコードがデッドロックになるのはどのパターンか」や「volatile変数で防げる問題は何か」などの形で出題されることがあります。基本的な概念（スレッドの優先度やスケジューリング、スレッドのライフサイクル）も押さえておきましょう。
ExecutorServiceを使った並行実行も出題されます。スレッドプールからタスクを送信する方法（execute()とsubmit()の違い）、タスク完了を待機する方法（awaitTerminationやinvokeAllなど）も理解しておくと安心です。
Parallel Streamについても、直列ストリームとの違いや注意点を把握してください。並列化により処理順序が保証されなくなる点や、スレッド数はForkJoinPoolの設定に依存する点、処理内容によっては並列化で性能が向上しないケースがあることなどが考えられます（試験では主に並列ストリーム使用時の結果の違いなどが問われます）。順序を保証したい場合はforEachOrderedを使う必要がある、といった知識も役立ちます ￼。
	•	モジュールシステム – JPMS（Javaモジュール）の分野は、新しい概念ゆえに油断すると理解が浅くなりがちですが、試験でも複数問が出題されることがあります ￼。モジュール定義の基本（requiresでモジュール依存関係を宣言し、exportsで特定パッケージを公開する）、モジュールパス上で動作する際のアクセス制御ルール（公開していないパッケージのクラスは読み込めない）を押さえましょう。モジュールグラフ上の循環依存や、不足モジュールによるNoClassDefFoundError相当のエラーなど、典型的なエラーケースと解決方法も理解しておいてください。サービスローダーを用いた実装の動的発見もJPMS特有のトピックです。実際の業務でモジュールを使った経験が無い場合でも、試験のために黒本や公式チュートリアルで基礎を固めておく必要があります ￼。
	•	ジェネリクスと例外処理の落とし穴 – ジェネリクスでは型安全性に関する引っかけ問題が出ます。例えば「List list = new ArrayList<String>();のように総称型を指定せずにリストを扱うコード」はコンパイル警告となるだけでエラーにはなりませんが、このリストから要素を取り出す際にはキャストが必要で、誤ったキャストをすると実行時例外ClassCastExceptionを招く点などです ￼。総称型パラメータを省略するとList<Object>相当とみなされる仕組みや、Raw型を混在させるリスクを理解しておきましょう ￼。
また、ワイルドカードを使ったリストの受け渡しも定番です。List<? extends SuperClass>とList<? super SubClass>では格納・取得の可否が異なります。? extends TはTのサブクラス型の要素しか受け取れず読み取り専用に近い（プロデューサ）、? super TはTのスーパークラス型であれば要素追加可能（コンシューマ）といった原則を押さえてください ￼。このあたりは実装コードを頭で追いにくいので、実際にコードを書いて動作確認してみるのも有効です。
例外処理ではマルチキャッチ構文の注意点として、継承関係にある例外クラスを一つのcatchでまとめて指定できないというルールがあります ￼。例えばcatch(IOException | FileNotFoundException e)のように、FileNotFoundExceptionがIOExceptionのサブクラスである場合はコンパイルエラーになります（どちらか一方に絞る必要がある）。このような文法上の制約も問われやすいポイントです。
さらに、カスタム例外クラスを作成する際は、チェック例外にする場合はExceptionを継承しなければならないとか、エラーと例外の違い（Errorはチェックされない重大エラー）といった基本も問われる可能性があります。try-with-resourcesではリソースがAutoCloseableを実装している必要があることや、マルチキャッチとリソース閉鎖の順序（抑制された例外が発生し得ること）など細かな点も黒本で確認しておくと良いでしょう。
	•	その他APIや機能の注意点 – ファイルI/Oでは、ファイルやディレクトリ操作時の挙動の違いに関する知識が求められます。例えば「既に存在するファイルをFiles.createFileで作成したらどうなるか」（例外が投げられる）や、「親ディレクトリが存在しない状態でFiles.createDirectoriesを呼んだらどうなるか」（中間ディレクトリも含めて作成される）などケースごとの結果を知っておくと安心です ￼。Path#resolveやresolveSibling、relativizeといったパス操作メソッドの機能も押さえておきましょう ￼。特にrelativizeは引数に与えたパスを基準から見た相対パスに変換しますが、両者の片方が絶対パスで片方が相対パスだと例外になる等の決まりがあります。
JDBCでは、正しい接続文字列の書式（例：jdbc:oracle:thin:@<ホスト>:<ポート>:<SID>）や、DriverManager.getConnection()に渡すユーザ名/パスワードの指定方法など基本を確認してください。またSQL実行メソッドの使い分けも重要です。executeQueryはSELECT文専用で戻り値はResultSet、executeUpdateはINSERT/UPDATE/DELETE文で戻り値は更新件数、executeは戻り値がboolean（結果がResultSetかどうか）で、DDLやプロシージャなど汎用的に使うもの、といった違いを覚えます ￼。
PreparedStatementについては、?プレースホルダへの値バインドに関する注意点がよく問われます。例として、setXXXメソッドでのプレースホルダ番号は1開始であるため「1番目の?に0を指定するとエラーになる」 ￼、あるいは全ての?に対して値を設定しないと実行時エラーになること、executeQueryを連続で呼ぶ際は適切にsetXXXで値を更新し直さないと以前の値が残ることなどです ￼。ResultSetの扱いも注意が必要で、取得直後はカーソルが先頭行の前にあるためnext()で進めてからでないとgetXXXで値を取り出せずエラーになる点 ￼、これも定番の引っかけです。
ローカライズは出題数こそ多くありませんが、ResourceBundleがどのプロパティファイルを選択するか（ロケールと言語コード・国コードのマッチングのルール）や、Localeのビルダー/ファクトリメソッドの使い方（Locale.of("ja","JP")等）を知っておくと良いでしょう。日付や数値のフォーマッタは、和暦の表記など凝ったものは出ませんが、NumberFormat.getCurrencyInstance(locale)の結果が通貨記号付きになる、といった基本を確認してください。
アノテーションは試験では頻出ではない分野ですが、@Overrideや@Deprecatedなどよく使われるアノテーションの効果は知っておきましょう ￼。例えば@Overrideは継承元のメソッドとシグネチャが合っていないとコンパイルエラーになる、といった点です。独自アノテーション作成時の@Retention(RetentionPolicy.RUNTIME)などの指定の意味（ソースのみか、クラスにも残すか、実行時参照可能か）も問われる可能性があります。
セキュアコーディングに関しては、コードの穴埋め問題というより概念的な設問になる傾向があります。例えば「JavaアプリケーションでDoS攻撃を防ぐにはどうすべきか」「入力検証で防げる脅威は何か」など、セキュリティ対策のベストプラクティスを選ばせる問題です ￼。基本的な方針（外部から渡される入力は信用せずホワイトリストで検証する、機密データは適切にマスキングする、不必要にpublicなクラスやメソッドを作らない、シリアライズ可能クラスには注意する等）を理解しておきましょう。

なお、Java Silver試験ではあまり深入りしなかったラムダ式やAPI周り（StreamやファイルI/O、並行処理など）がJava Goldでは本格的に問われる分野になっています ￼。過去にこれらが苦手だった方は重点的に学習することをおすすめします。また、公式サイト掲載の試験範囲 ￼および市販の問題集（黒本）に沿って、取りこぼしのないよう幅広く準備すると良いでしょう。時間をかけた丁寧な学習が合格への近道です。頑張ってください！

参考資料: Oracle公式: Java SE 11 Gold試験範囲 ￼ ￼、Black Book徹底攻略解説 ￼ ￼など各種日本語学習サイトより。