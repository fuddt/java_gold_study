# ローカルクラスとは何か？

定義

メソッドの中で定義されるクラス
```
void method() {
    class LocalClass {
        void hello() {
            System.out.println("hello");
        }
    }
}
```
## 特徴まとめ

- 定義できる場所：メソッド・コンストラクタ・初期化ブロック
- アクセス修飾子：使えない（public / private / protected ×）
- static：使えない
- インスタンス生成：そのスコープ内のみ

## 直感的に思ったこと
いつ使う？？？？？？

- クラス定義がメソッドの途中に割り込む
- スコープが特殊すぎる
- これ、普通のクラスしたら？？？

とかいろいろ思った。それでもローカルクラスにしたいときってどんなときなんだろう？？

って考えても試験で出るんだから文句言わず覚えます。



# 変数の参照で以下のようなことができる

```java
public class Main {
    public static void main(String[] args) {
        int x = 10; // 参照できる

        class Local {
            void print() {
                System.out.println(x);
            }
        }

        new Local().print();
    }
}

java --module-path out -m app/app.Main                        
10
```

で、注意なのが、xは実質finalな性質になります。

```java
public class Main {
    public static void main(String[] args) {
        int x = 10; // 参照できる

        class Local {
            void print() {
                
                System.out.println(x);
            }
        }
        x = 20; // 変更するとコンパイルエラー
        new Local().print();
    }
}
```

```bash
javac --module-source-path src -d out $(find . -name "*.java")
./src/app/Main.java:10: エラー: 内部クラスから参照されるローカル変数は、finalまたは事実上のfinalである必要があります
                x = 20; // 変更するとコンパイルエラー
```

ちなみに以下の場合でも同じ

```java
package app;


public class Main {
    public static void main(String[] args) {
        int x = 10; // 参照できる

        class Local {
            void print() {
                
                System.out.println(x);
            }
        }
        x = 20; // 変更するとコンパイルエラー ここでもダメなのか
        new Local().print();
    }
}
```


```bash
javac --module-source-path src -d out $(find . -name "*.java")
./src/app/Main.java:11: エラー: 内部クラスから参照されるローカル変数は、finalまたは事実上のfinalである必要があります
                System.out.println(x);
                                   ^
エラー1個
```

って感じです。


# 無名クラスについて

無名クラスはローカルクラスの一種で、クラス名がないクラスのことを指します。主にインターフェースや抽象クラスを実装・継承するために使用されます。


## 無名クラスとは何か

クラス定義とインスタンス生成を同時にやる構文

```java
Runnable r = new Runnable() {
    int count = 0;

    @Override
    public void run() {
        count++;
        System.out.println(count);
    }
};
r.run(); // 1
r.run(); // 2
r.run(); // 3
```
- クラス名は存在しない
- でも「クラス」は作られている
- new Runnable() の {} がクラス本体

```java

package app;


public class Main {
    public static void main(String[] args) {

        Runnable r = new Runnable() {
            int count = 0;

            @Override
            public void run() {
                count++;
                System.out.println(count);
            }
        };
        r.run(); // 1
        r.run(); // 2
        r.run(); // 3
    }
}
```
```bash
java --module-path out -m app/app.Main                        
1
2
3
```

状態が持ちつつ関数を実行していきたいときに便利って感じですね。


ラムダ
- 関数なので状態（フィールド）を持たない
- 毎回同じ入力 → 同じ振る舞い、という発想

例えばラムダだと以下のように書いても毎回同じになっちゃう

```java
Runnable r = () -> {
    int count = 0;   // 毎回初期化される
    count++;
    System.out.println(count);
};
r.run(); // 1
r.run(); // 1
r.run(); // 1
```
```
java --module-path out -m app/app.Main
1
1
1
```

対する無名クラスは
- インスタンスが生成される
- フィールドを持てる＝状態を保持できる
- 実行のたびに内部状態が変わり得る

というのが便利なところかと思う。