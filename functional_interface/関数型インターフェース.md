
## 1. 関数型インタフェースとは何か

**抽象メソッドがちょうど1つだけ定義されているインタフェース**


```
Interface（概念としての入れ物）
 ├─ 普通のインタフェース
 └─ 関数型インタフェース（条件を満たしたもの）
```


重要なのは「抽象メソッドが1つ」という一点だけ。
なにかInterfaceの構造が異なるとかそういうわけじゃない

```
interface Flyable {
    void fly();
}


interface MyFunc {
    int apply(int x);
}
```
上記の2つはどちらも関数型インタフェースと呼べる.

明確にするために、Javaでは
`@FunctionalInterface` アノテーションが用意されている。

```java
@FunctionalInterface
interface MyFunc {
    int apply(int x);
}
```
このアノテーションを付けると、**コンパイル時に関数型インタフェースの条件を満たしているかチェックされる**。

なので、例えばアノテーションをつけたinterfaceに抽象メソッドが2つ以上あるとコンパイルエラーになる。
```java
@FunctionalInterface
interface MyFunc {
    int apply(int x);
    int calc(int y);   // ← ここでコンパイルエラー
}
```

ひっかけ問題。
「抽象メソッドが１つ」なら良いので以下は関数型インターフェースに
```java
interface A {
    int x(int a);

    default int y(int b) { return b; }
    default int z(int c) { return c; }
}
```

なる！

だって 抽象メソッドは1つだけ だから。default メソッドはカウントしない。


あとおまけで、Objectクラス由来のメソッドもカウントしない。

```java
interface A {
    int x(int a);
    boolean equals(Object o);
}
```
これも関数型インターフェースになる。

private メソッドもカウントしないよ。

```java
interface MyFunc {
    int apply(int x);
    private void log() {
        System.out.println("log");
    }
}
```
これも関数型インターフェースになる。


## 関数型インターフェースの使用例
ラムダ式を代入する際の型として使う

```java
@FunctionalInterface
interface MyFunc {
    int apply(int x);
}
public class Main {
    public static void main(String[] args) {
        MyFunc f = x -> x * 2;  // ラムダ式を代入
        System.out.println(f.apply(5));  // 出力: 10
    }
}
```


コールバック関数が一番わかりやすいかも？
コールバック関数を受け取るメソッドを定義したときに、その関数の型として関数型インターフェースを使う。

```java
package app;

/**
 * 数値を1つ受け取って、数値を返す
 * 抽象メソッドが1つだけなので関数型インタフェース
 */
@FunctionalInterface
interface IntProcessor {

    // 抽象メソッドは1つだけ
    int process(int x);

    // default メソッドはあってもOK（抽象メソッドに数えない）
    default void log(int x) {   
        System.out.println("input = " + x);
    }
}


public class Main {

    public static void main(String[] args) {

        // ① ラムダ式で実装（2倍にする処理）
        IntProcessor doubleProcessor = x -> x * 2;

        // ② ラムダ式で実装（2乗する処理）
        IntProcessor squareProcessor = x -> x * x;

        // ③ 処理を「引数として」渡す
        execute(5, doubleProcessor);
        execute(5, squareProcessor);

        // ④ その場限りの処理も書ける（使い捨て）
        execute(5, x -> x + 10);
    }

    /**
     * 数値と「処理」を受け取って実行するメソッド
     */
    private static void execute(int value, IntProcessor processor) {

        // default メソッドも呼べる
        processor.log(value);

        int result = processor.process(value);
        System.out.println("result = " + result);
        System.out.println("-----");
    }
}

```

```bash
input = 5
result = 10
-----
input = 5
result = 25
-----
input = 5
result = 15
-----
```

このコードで何が「便利」なのか
① 処理を差し替えられる

```
        execute(5, doubleProcessor);
        execute(5, squareProcessor);
```
同じexecuteメソッドに対して、処理を差し替えて呼び出せる。

②「動作」を値として扱える
関数型インターフェースを使うことで、処理（動作）を値として扱える（上記の例）
これにより、関数を引数として渡したり、変数に代入したりできる。

```
IntProcessor p = x -> x * 2;
int result = p.process(5);  // result は 10
```
- 数値
- 文字列

と同じレベルで
「処理」そのものを変数に入れている

関数型インタフェースは
「処理を引数として渡すための型」